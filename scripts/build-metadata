#! /usr/bin/env python
import os
import sys
import argparse
import json
from distutils.dir_util import mkpath
import fnmatch
import re
import warnings
import subprocess
import collections

import paramiko
import getpass
import yaml


class cd(object):
    def __init__(self, dir):
        self._dir = dir

    def __enter__(self):
        self._starting_dir = os.path.abspath(os.getcwd())
        if not os.path.isdir(self._dir):
            mkpath(self._dir)
        os.chdir(self._dir)
        return os.path.abspath(os.getcwd())

    def __exit__(self, type, value, traceback):
        os.chdir(self._starting_dir)


# See https://stackoverflow.com/a/21499676/1563298
def commonpath(l):
    cp = []
    ls = [p.split(os.path.sep) for p in l]
    ml = min(len(p) for p in ls)

    for i in range(ml):
        s = set(p[i] for p in ls)
        if len(s) != 1:
            break
        cp.append(s.pop())

    return os.path.sep.join(cp)


def load_config(file_like):
    return yaml.load(file_like)


def load_wmt_config(file_like):
    return yaml.load(file_like)


def load_host_info(info_file):
    with open(info_file, 'r') as fp:
        info = json.load(fp)
    return info


def open_connection(hostname, username, password):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        ssh.connect(hostname, username=username, password=password)
    except paramiko.SSHException:
        raise

    return ssh


def dump_info(info, api):
    info['id'] = api['class']
    info['name'] = api['class']
    info['class'] = api['class']
    try:
        info['initialize_args'] = api['initialize_args']
    except KeyError:
        warnings.warn('missing initialize_args')
        info['initialize_args'] = ''

    with open('info.json', 'w') as fp:
        json.dump(info, fp, indent=4)


def pop_ignored_params(params, ignore):
    names = params.keys()

    ignored = []
    for pattern in ignore:
        p = re.compile(fnmatch.translate(pattern))
        ignored.extend(filter(p.match, params))

    for name in ignored:
        if name in params:
            # params.pop(name)
            params[name]['visible'] = False
        else:
            if name not in names:
                warnings.warn('{name}: pattern not in params'.format(name=name))


def add_extras(params, extras):
    params.update(extras)


def set_globals(params, globals):
    for name in globals:
        if name in params.keys():
            params[name]['global'] = True


def section_break(title):
    return {
        'key': 'separator',
        'name': title,
        'description': title,
        'value': {
            'type': 'string',
            'default': '',
        }
    }


def old_style_parameter(name, param):
    return {
        'key': name,
        'name': param['description'],
        'description': param['description'],
        'value': param['value'],
        'visible': param.get('visible', True),
        'global': param.get('global', False)
    }


def make_sections(ordered_params, params, sections):
    added = set()

    for name in params.keys():
        if params[name].has_key('global') and params[name]['global'] is True:
            try:
                ordered_params.append(old_style_parameter(name, params[name]))
            except KeyError:
                warnings.warn('{name}: missing parameter'.format(name=name))
            else:
                added.add(name)

    for section in sections:
        ordered_params.append(section_break(section['title']))
        for member in section['members']:
            try:
                ordered_params.append(old_style_parameter(member, params[member]))
            except KeyError:
                warnings.warn('{name}: missing parameter'.format(name=member))
            else:
                added.add(member)

    missing = set(params.keys()) - added
    if len(missing) > 0:
        # ordered_params.append(section_break('Invisible Parameters'))
        for name in missing:
            params[name]['visible'] = False
            ordered_params.append(old_style_parameter(name, params[name]))

    return ordered_params


def make_groups(params, groups):
    for group, members in groups.items():
        for item in params:
            if item['key'] in members:
                item['group'] = {
                    "name": group,
                    "leader": item['key'] == members[0],
                    "members": len(members),
                }
    return params


def get_mapped_parameters(roles):
    mapped_params = [roles['selector']]
    for mapping in roles['selections']:
        param = mapping.values()[0]
        try:
            mapped_params.index(param)
        except ValueError:
            mapped_params.append(param)
    return mapped_params


def get_mappings(selections):
    mappings = collections.OrderedDict()
    for mapping in selections:
        for ptype, param in mapping.items():
            mappings[ptype] = param
    return mappings


def make_mappers(params, mappers):
    for mapper, roles in mappers.items():
        mapped_params = get_mapped_parameters(roles)
        for item in params:
            if item['key'] in mapped_params:
                item['selection'] = {
                    'name': mapper,
                    'selector': roles['selector'] == item['key'],
                    'members': len(mapped_params),
                    }
                if item['selection']['selector'] is True:
                    item['selection']['mapping'] = get_mappings(roles['selections'])
    return params


def dump_parameters(params, wmt_config):
    if wmt_config.has_key('extras'):
        add_extras(params, wmt_config['extras'])

    if wmt_config.has_key('ignore'):
        pop_ignored_params(params, wmt_config['ignore'])

    plist = []
    if wmt_config.has_key('globals'):
        driver = section_break('Globals')
        driver['global'] = True
        plist.append(driver)
        set_globals(params, wmt_config.get('globals', []))

    plist = make_sections(plist, params, wmt_config.get('sections', []))
    plist = make_groups(plist, wmt_config.get('groups', {}))
    plist = make_mappers(plist, wmt_config.get('parameter_mappers', {}))
    with open('parameters.json', 'w') as fp:
        json.dump(plist, fp, indent=4)


def dump_files(files):
    prefix = commonpath(files)
    shortened_files = []
    if len(files) == 1:
        prefix = os.path.dirname(prefix)
    prefix += os.path.sep
    for name in files:
        shortened_files.append(name[len(prefix):])

    with open('files.json', 'w') as fp:
        json.dump(shortened_files, fp, indent=4)


def dump_uses(uses_names, wmt_config):
    ports = []

    uses = wmt_config.get('uses', [])
    for name in uses:
        names = []
        for pattern in uses[name]['exchange_items']:
            p = re.compile(fnmatch.translate(pattern))
            names.extend(filter(p.match, uses_names))

        ports.append({
            'id': name,
            'required': uses[name]['required'],
            'exchange_items': uses[name]['exchange_items'],
        })

    with open('uses.json', 'w') as fp:
        json.dump(ports, fp, indent=4)


def dump_provides(provides_names, wmt_config):
    ports = []
    provides = wmt_config.get('provides', [])
    for name in provides:
        names = []
        for pattern in provides[name]['exchange_items']:
            p = re.compile(fnmatch.translate(pattern))
            names.extend(filter(p.match, provides_names))

        ports.append({
            'id': name,
            'required': provides[name]['required'],
            'exchange_items': names,
        })

    with open('provides.json', 'w') as fp:
        json.dump(ports, fp, indent=4)


def build_file_list(config, prefix='.'):
    all_files = []
    for name, component in config['components'].items():
        datadir = commonpath(component['files'])
        if len(component['files']) == 1:
            datadir = os.path.dirname(datadir)
        datadir += os.path.sep
        for file in component['files']:
            all_files.append(
                (file,
                 os.path.join(name, 'files', file[len(datadir):])))

            # all_files.append(
            #     (file,
            #      os.path.join(prefix, name, 'files', os.path.basename(file))))

    return all_files


def add_output_vars_to_params(params, sections, provides):
    print_section = {
        'title': 'Output files',
        'members': [],
    }
    for name in provides:
        params[name] = {
            'description': name,
            'value': {
                'type': 'choice',
                'default': 'off',
                'choices': [
                    'off',
                    name
                ]
            }
        }
        print_section['members'].append(name)

    sections.append(print_section)


def fetch_config(hostname, hostpath=None, username=None, password=None):
    config_file = 'wmt-config-{}.yaml'.format(hostname)

    cmd = 'PATH={}:$PATH;cmt-config > /tmp/{}'.format(hostpath, config_file)
    ssh = open_connection(hostname, username, password)
    ssh.exec_command(cmd)
    ssh.close()

    ssh = open_connection(hostname, username, password)
    sftp = ssh.open_sftp()
    with cd(project_dir):
        sftp.get(config_path_exe, config_file)
        config = load_config(config_file)
    ssh.close()

    return config


def build_metadata(config, prefix='.'):
    for name, component in config['components'].items():
        with cd(os.path.join(prefix, name)):
            with open('wmt.yaml', 'r') as fp:
                wmt_config = load_wmt_config(fp)

        if len(component.get('provides', [])) > 0:
            add_output_vars_to_params(component['parameters'],
                                      wmt_config['sections'],
                                      component.get('provides', []))

        with cd(os.path.join(prefix, name, 'db')):
            dump_info(component['info'], component['api'])
            dump_parameters(component['parameters'], wmt_config)
            dump_files(component['files'])
            dump_uses(component['uses'], wmt_config)
            dump_provides(component['provides'], wmt_config)


def fetch_files(config, prefix='.'):
    files_to_fetch = build_file_list(config, prefix=prefix)

    hostname = config['host']['hostname']
    username = os.environ['wmt_executor_username']
    password = getpass.getpass()

    ssh = open_connection(hostname, username, password)
    sftp = ssh.open_sftp()

    # def callback(bytes, total):
    #     print '{bytes} / {total}'.format(bytes=bytes, total=total)

    with cd(prefix):
        for src, dst in files_to_fetch:
            print '{src} --> {dst}'.format(src=src, dst=dst)
            with cd(os.path.dirname(dst)):
                sftp.get(src, os.path.basename(dst))
            # sftp.get(src, os.path.basename(dst), callback=callback)


def main():
    prefix = os.path.dirname(sys.prefix)

    parser = argparse.ArgumentParser()
    parser.add_argument('config_file', type=argparse.FileType('r'),
                        nargs='?',
                        help='Execution server configuration file')
    parser.add_argument('--prefix', default=prefix,
                        help='Path to server installation')
    parser.add_argument('--hostname', default='siwenna.colorado.edu',
                        help='Hostname of execution server')
    args = parser.parse_args()

    if args.config_file is not None:
        config = load_config(args.config_file)
    else:
        info_file = os.path.join(args.prefix, 'db', 'hosts',
                                 args.hostname, 'db', 'info.json')
        info = load_host_info(info_file)

    build_metadata(config, prefix=os.path.abspath(args.prefix))
    fetch_files(config, prefix=os.path.abspath(args.prefix))


if __name__ == '__main__':
    main()
